# JVM

## jvm分析

为什么使用JVM?

![image-20200514091741675](upload\image-20200514091741675.png)

**字节码和机器码的区别？**

- 机器码是电脑cpu直接读取运行时的机器指令，运行速度最快，但是非常晦涩难懂。一般从业人员基础不到。
- 字节码是一种中间状态的二进制代码文件，需要直译器转译后才能成为机器码。

JDK JRE JVM关系

JDK: java 开发工具包

JRE:java运行时环境

JVM:java虚拟机

![image-20200514093721204](upload\image-20200514093721204.png)

OpenJDK OracleJDK的关系 Oracle JDK 10以后要收费

JVM和Hotspot的关系是什么

JVM是《JVM虚拟机规范》中提出来的规范

Hotspot是使用jvm规范的商用产品，除此之外还有BEA、Jrockit、IBM的J9也是JVM产品

JVM和Java的关系是什么

java语言 Scala语言 Groovy语言 其他语言 编译成 class 语言 ，在JVM中运行

JVM两种运行模式： cliean、server

​	两种方式的区别与联系：

1. client模式的启动速度比较快，server模式的启动速度比较慢
2. 但是启动后进入长期稳定的运行态server模式的程序运行速度比clent快
3. 但是因为server模式启动jvm采用的是重量级的虚拟机，对程序进行了很对优化；而client模式启动虚拟机采用的是轻量级的虚拟机，所以server启动速度慢，但是稳定后比client运行速度快

JVM架构图

![image-20200514094603500](upload\image-20200514094603500.png)

### jvm执行流程

java代码编译成字节码文件，动态编译和解释为机器码的过程分析：

![image-20200514094857936](upload\image-20200514094857936.png)

编译器和解释器协调工作流程分析：

![image-20200514095020976](\upload\image-20200514095020976.png)

## JIT即使编译器

**在部分商用虚拟机中如（Hotspot），java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或者代码块运行特别频繁的时候，就会认为这段代码为热点代码，为了提高热点代码在虚拟机中的执行效率，在运行时，虚拟机会将这些代码编译成与本地平台无关的机器码，进行各层的优化，完成这个任务的编译器被称作即时编译器（Just In Time Compiler，统称为JIT）**

解释器和编译器的优缺点？

- 程序需要快速启动时，为了省去编译时间，用解释器。程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码后，可以获得更高的执行效率。
- 当程序运行环境中的资源限制比较大，可以使用解释器节约内存，反之用编译器

热点代码的动态编译

动态编译的一种：在运行时进行编译，狭义的来说某一段代码即将执行时进行编译，JIT编译是以方法为单位进行编译的，编译成机器码

**如何判断是否时热点代码？**如何去记录方法调用次数和循环体的循环次数呢？

基于计数器：

- **方法调用计数器**：方法对象中去存储调用次数
- **回边计数器**：每一次循环回去，都会记录一次次数

解释器：逐条解释进行编译

**JVM为什么需要使用解释器和编译器并存的架构？**

- 当程序需要迅速启动和执行的时候，解释器首先发挥作用，省去代码编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码后，可以获得更高的执行效率
- 当程序运行环境中内存资源限制较大，可以使用解释器执行节约内存，反之需要使用编译器来提升性能

**JVM为什么需要两个即时编译器？**

- HotSpot虚拟机内置了两个即时编译器：Client Compiler和Server Compiler，简称为c1和c2编译器。分别用在客户端和服务端

- 目前主流的HotSpot虚拟机默认是采用解释器与其中一个编译器直接配合的方式工作。程序使用哪一个编译器取决于虚拟机的运行模式
- 用Client Compiler获得更高的编译速度，用Server Compiler获得更好的编译质量

**哪些程序会被编译？**

只有代码是热点代码时，才会编译为本地代码，**那么什么是热点代码？**分两类

- 多次被调用的方法
- 被多次执行的循环体

### JIT优化

- 公共子表达式消除：是一种普遍用于各种编译器的经典的优化方法，它的含义是：如果一个表达式已经计算过了，而且从计算到现在E中的值没有发生变化，那么E的这次出现就成了公共子表达式。对于这种表达式没有必要再进行计算。只需要直接用前面计算过的表达式结果代替E即可。

![image-20200514101436885](upload\image-20200514101436885.png)

- 方法内联：将方法调用直接使用方法体中的代码进行替换，减少了方法调用过程中的压栈与入栈的开销

![image-20200514102000187](upload\image-20200514102000187.png)

- 逃逸分析（Escape Analysis）：有效减少java程序中同步负载和内存堆分配压力。逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法上被定义后，它可能被外部方法引用。例如作为调用参数传递到其他方法中，称为方法逃逸。
  - 逃逸分析包括：
    - 全局变量逃逸分析
    - 方法返回值逃逸
    - 实例引用逃逸
    - 线程逃逸：赋值给类变量或者可以在其他线程中访问的实例变量
  
- 对象的栈上内存分配：我们都知道一般对象和数组的内存分配都是在堆上进行的，但是随着jit即时编译技术的成熟，很多优化使得这种分配策略并不绝对。jit即时编译器就可以在编译期间根据逃逸分析的结果，类决定对象的内存分配是否可以从堆上转移到栈上

- 标量替换：

  - **标量**是指一个无法再分解为更小数据的数据。

  如果在JIT阶段发现一个对象没有被外界访问。那么经过JIT优化，会把这个对象拆解成其所包含的成员变量来替换。

  ![image-20200514105455686](upload\image-20200514105455686.png)

- 同步锁消除 ：同样基于逃逸分析，当加锁的变量不会发生逃逸，是线程私有的完全没有必要加锁。在编译期就可以将同步锁去掉，以减少加锁和解锁引起的资源开销
  - -XX:+DoEscapeAnalysis -XX:-EliminateLocks (开启逃逸分析，关闭同步锁消除  )
  - -XX:+DoEscapeAnalysis -XX:+EliminateLocks(开启逃逸分析，开启同步锁消除)

jdk1.7默认开启了逃逸分析

jmap -histo 进程号

##  class文件分析

**常量池在class文件中的位置？**

![image-20200514111023295](upload\image-20200514111023295.png)

| 类型           | 名称                       | 数量                  |
| -------------- | -------------------------- | --------------------- |
| u4             | magic（魔数）              | 1                     |
| u2             | minor_version(jdk次版本哈) | 1                     |
| u2             | major_version(jdk主版本号) | 1                     |
| u2             | constant_pool(常量池)      | 1                     |
| cp_info        | constant_pool(常量表)      | constant_pool_count-1 |
| u2             | access_flags(访问标志)     | 1                     |
| u2             | this_class(类引用)         | 1                     |
| u2             | super_class(父类引用)      | 1                     |
| u2             | interface_count(接口数量)  | 1                     |
| u2             | interfaces(接口数组)       | interfaces_count      |
| u2             | fields_count(字段数量)     | 1                     |
| field_info     | fields(字段表)             | fields_count          |
| u2             | methods_count(方法数量)    | 1                     |
| method_info    | methods(方法表)            | methods_count         |
| u2             | attributes_count(属性数量) | 1                     |
| attribute_info | attributes(属性表)         | attributes_count      |

#### 魔数

**所有java编译器编译而成的class文件的前4个字节都是 “0xCAFEBABE” (咖啡宝贝)**

#### 版本号

主版本号和副版本号在class文件中都各自占用两个字节，副版本号占用5、6字节，主版本号占用7、8字节

![image-20200514164525503](upload\image-20200514164525503.png)

javap -v Math(Math为 .class文件)

![image-20200514164740112](upload\image-20200514164740112.png)

#### 常量池计数器

常量池是class文件中非常重要的结构，它描述整个class文件的字面量信息。常量池是由一组constant_pool结构体数组组成的，而数组的大小则由常量池计数器指定的。常量池计数器constant_pool_count的值 = contant_pool中的成员数+1,constant_pool表的索引值只有在大于0且小于constant_pool_count时才会被认为是有效的。

> [<u>注意</u>：常量池计数器默认是从1开始的而不是0开始的。当constant_pool_count =1 时，表示常量池cp_info中的个数为0个，当constant_pool_count 为 n 时，表示常量池cp_info中的个数为n-1。]()

#### 常量池数据区

![image-20200512075840505](http://q8sats5bw.bkt.clouddn.com/img/image-20200512075840505.png)

cp_info: 常量池项

constant_pool_count: 常量池计数器

![class常量池数据区](http://q8sats5bw.bkt.clouddn.com/img/image-20200512072913009.png)

[**常量池cp_info的结构是什么样子的？**]()

![image-20200514170941123](upload\image-20200514170941123.png)

JVM虚拟机规定了不同的tag值对应不对的字面量类型

![image-20200514171041903](upload\image-20200514171041903.png)

根据cp_info中tag的不同的值，可以将cp_info更细化为以下结构体
![image-20200514195506925](upload\image-20200514195506925.png)

#### string 类型的字符串常量在class常量池中如何存储

对于字符串而言，JVM会将字符串类型的字面量以UTF-8的编码格式存储到class文件中。就是JAVA源码中用“”括起来的字符串，在编译期间都会把这些字符串转换成constant_String_info结构体，然后放置于class常量池中。其结构如下图所示：

![image-20200514201029162](upload\image-20200514201029162.png)

如上图所示的结构体,constant_String_info结构体中的string_index的值指向了constant_utf8_info结构体，而字符串的uff-8编码就在这个结构体中，如下图所示：

![image-20200514201741262](upload\image-20200514201741262.png)

#### **类文件中定义的类名和类中使用到的类在常量池中如何定义？**

Jvm会将某个java类中使用到的所有类的完全限定名以二进制形式的完全限定名封装到constant_class_info结构体中，然后将其放入常量池中，constant_class_info的tag值为7。其结构如下：
![image-20200514202527522](upload\image-20200514202527522.png)

[``Tips：类的完全限定名和二进制形式的完全限定名`
`在某个Java源码中，我们会使用很多个类，比如我们定义了一个 ClassTest的类，并把它放到`
`com.kkb.jvm 包下，则 ClassTest类的完全限定名为com.kkb.jvm.ClassTest，将JVM编译`
`器将类编译成class文件后，此完全限定名在class文件中，是以二进制形式的完全限定名存储`
`的，即它会把完全限定符的"."换成"/" ，即在class文件中存储的 ClassTest类的完全限定名`
`称是"com/kkb/jvm/ClassTest"。因为这种形式的完全限定名是放在了class二进制形式的字`
节码文件中，所以就称之为 二进制形式的完全限定名`]()  

![image-20200514202750819](upload\image-20200514202750819.png)

#### 哪些字面量会进入常量池中？

- final 类型的8中基本数据类型的值会进入常量池
- 非final类型（包括static）的8中数据类型，只有double,float,long的值会进入常量池
- 常量池中包含的字符串类型的字面量(双引号引起来的字符串值)

#### class文件中的特殊引用和特殊字符串

##### 符号引用

符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候能够无歧义的定位到目标即可。

在java中，一个java类将编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能用符号引用来代替了。

##### 直接引用

直接指向目标的指针（比如：指向“类型”[class对象]、类变量、类方法的直接引用可能是指向方法区的指针）

相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）

一个能间接定位到目标的句柄

符号引用转换成直接引用发生在类加载的过程中(加载 -> 连接（验证、准备、解析）-> 初始化)中的解析阶段，会将符号引用转换成直接引用，放入**运行时常量池中**

[**描述符**]()

各类型的描述符：

- 基本数据类型(byte、char、double、float、int、long、short、boolean)：除了long和boolean外，其他数据类型都用对饮单词的大写字母表示。long 用 J 表示、boolean 用 z表示
- void 描述符为 V
- 对象类型：描述符用字符L加上对象的全限定名表示，如String类型的描述符为Ljava/lang/String。
- 数组类型：每增加一个维度则在对应字段描述符前面加一个[ ,如一维数组int[]的描述符为[I，二维数组String[][] 的描述符为[[Ljava/lang/String。

### 通过javap 命令分析java指令

**javap命令概述**：

javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区
（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。
当然这些信息中，有些信息（如本地变量表、指令和代码行偏移量映射表、常量池中方法的参数名称等
等）需要在使用javac编译成class文件时，指定参数才能输出，比如，你直接javac xx.java，就不
会在生成对应的局部变量表等信息，如果你使用javac -g xx.java就可以生成所有相关信息了。如果
你使用的eclipse，则默认情况下，eclipse在编译时会帮你生成局部变量表、指令和代码行偏移量映
射表等信息的。
通过反编译生成的汇编代码，我们可以深入的了解java代码的工作机制。比如我们可以查看i++；这行
代码实际运行时是先获取变量i的值，然后将这个值加1，最后再将加1后的值赋值给变量i。
通过局部变量表，我们可以查看局部变量的作用域范围、所在槽位等信息，甚至可以看到槽位复用等信
息。

```shell
javap <options> <classes>
```

其中classes就是你要分解析的class文件，一般常用 -v -l -c 三个选项

## 类加载子系统

### 加载

**加载class文件到运行时数据区（存储到方法区，注意只针对Hotspot虚拟机）**

![image-20200512110539767](upload\image-20200512110539767.png)



![image-20200512110649708](upload\image-20200512110649708.png)

类和数组加载的区别：

数组也有类型，称为数组类型，如：

String[] str = new String[10];

**非数组加载通过类加载器完成**

**数组类：数组类本身不通过类加载器创建，它是通过java虚拟机直接创建，但是数组类与类加载器有很密切的关系，因为数组类的元素类型最终是要靠类加载器来创建**

在类加载过程中JVM主要做三件事情：

- 通过一个类的全限定性类名来获取定义该类的二进制字节流文件(class文件),在程序运行过程中，当要访问一个类的时候，如果发现这个类没有被加载，，并且满足类的初始化条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流，开始加载过程
- 将这个字节流的静态存储结构转化成方法区的运行时数据结构
- 在内存中创建一个java.lang.Class对象，则为该方法区该类的各种数据的访问入口

**HotSpot虚拟机将Class对象存放在方法区**

### 链接

#### 验证

**通过 -Xverify:none设置验证关闭**

**验证的目的：保证二级制字节流中的信息符合虚拟机规范，没有安全问题**

- 文件格式验证（KAFEBABE 魔数验证）
- 元数据验证：对字节码描述信息进行语义分析，确保符合java规范
- 字节码验证
- 符号引用验证

![image-20200515123512772](upload\image-20200515123512772.png)

#### 准备

- 为已经在方法区中的类的静态成员变量分配内存
- 为静态成员变量设置初始值，初始值为0、false、null等

![image-20200512113319234](upload\image-20200512113319234.png)

#### 解析

解析主要是虚拟机将常量池中的符号引用替换为直接引用的过程。

解析主要针对类或者接口、字段、类方法、接口方法四类符号引用进行，分别对应着class常量池中的constant_class_info、constant_fielderf_info、constant_methodref_info、constant_interfaceMethodref_info四种常量类型。

### 初始化

- 调用了<clinit>类初始化方法的过程，完成了对static修饰的变量的手动赋值还有主动调用静态代码块的过程

- <clinit>方法是编译器自动收集类中的所有类变量的赋值动作和静态语句块合并产生的，编译器收集的顺序是由语句在原文中出现的顺序决定的

- 静态代码块只能访问到出现在静态代码块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但是不能访问

```java
public class Test{
    static{
        static i = 0;
    	system.out.println(i); //编译失败： "非法向前引用"
    }
    
   static int i = 1;

}
```



- 实例构造方法<init>需要显示的调用父类的构造函数，而类的<clinit>方法不需要调用父类的构造函数。虚拟机会确保子类的<clinit>方法执行之前已经执行了父类的<clinit>方法。因为jvm中第一个执行的<init>方法的类肯定是java.lang.Object

- 接口也需要通过<clinit>方法为接口中定义的静态成员变量显示初始化。接口中不能使用静态代码块，但是仍然又变量初始化的赋值操作，因此接口与类一样都会生成<clinit>方法。不同的是，执行接口的<clinit>方法不需要先执行父接口的<clinit>方法。只有当父接口中的静态成员变量被使用到的时候才会执行父类的<clinit>方法。

- 虚拟机会保证在多线程中一个类的<clinit>方法被正确的加锁，同步。多线程同步时会去初始化一个类时，只会有一个线程去执行该类的<clinit>方法，其他线程都被阻塞等待，直到活动线程的<clinit>方法被执行完毕。同一个类加载器下，一个类型只会初始化一次。

java单例模式

静态内部类单例

```java
public class Student {
    private Student() {}
    // 此处使用一个静态内部类来维护单例，JVM在加载的时候是互斥的，由此可以保证线程安全问题
    private static class SingletonFactory {
        private static Student student = new Student();
    }
    
    public static Student getSingletonInstance() {
        return SingeltonFactory.student;
    }
}
```

### 类加载时机

遇到new、getstatic、putstatic、invokestatic这四个指令的时候，如果对应的类没有初始化，则需要进行初始化

这四个指令在我们java代码中的场景分别是：

- new关键字 实例化对象的时候
- 读取或者设置一个静态字段（读取被final修饰，已经在编译器把结果存入常量池的静态字段除外）；
- 调用类的静态方法的时候

使用java.lang.reflect包的方法时对类进行反射调用的时候

初始化一个类的时候发现其父类还没有初始化，要先初始化其父类

当虚拟机开启时，用户需要指定一个主类，虚拟机会先执行这个主类的初始化

### 类加载器

![image-20200515192931590](upload\image-20200515192931590.png)

启动类加载器（Bootstrap ClassLoader）

- 负责加载 JAVA_HOME\lib目录中
- 或者通过-Xbootclasspath参数设定路径中的，且被虚拟机认可的（按照文件名识别，如rt.jar）的类
- 由C++实现的不是ClassLoader的子类

扩展类加载器

- 负责加载JAVA_HOME\lib\ext 目录中的，
- 或者通过java.ext.dirs系统变量指令路径中的类库

应用程序类加载器

- 负责加载用户路径(classpath) 上的类库

JVM的类加载是通过ClassLoader及其子类来完成的，类的层级关系和加载顺序可以由下图来描述：

![image-20200515193148410](upload\image-20200515193148410.png)

加载的过程会先检查类是否已经被加载，检查顺序是自低向上，从Custom ClassLoader到Bootstrap ClassLoader逐层检查，只要有一个classLoader已加载视为已经加载过该类，保证此类只所以的classLoader加载一次，而加载的顺序是自顶向下，也就是说由上层逐层加载此类。

### 图解java对象创建过程

![image-20200515185632224](upload\image-20200515185632224.png)

- 虚拟机遇到new指令时，会检查这个指令的参数在常量池中是否定位到个类的符号引用，并且去检查这个符号是否被加载、解析、初始化过，如果没有必须完成类的加载过程

- 检查通过后，为新生对象分配内存空间。对象所需的内存空间的大小实在类加载完成后就能够确定的，为对象分配内存空间的任务就相当于将一定大小的内存空间从java堆中划分出来。

  > 假如堆中空间绝对的规整，所有用过的堆分配在一边，没有使用过的内存空间分配在一边，中间的分界点称为指示器，这种分配方式则称作指针碰撞（Bump the Pointer）

  > 假如堆内存空间不规整，使用过的和未使用过的相互交错，那么JVM需要维护一个列表来记录哪些是可用的内存空间哪些不可用，这种分配方式称为空闲列表（Free List）

  > 问题： 并发情况下，出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针分配内存。
  >
  > - 解决办法：a. 对分配的动作进行同步处理（原子性），实际上JVM采用的CAS配上失败重试的方法保持原子性。
  > - b. 不用线程分配在不同的空间，每个线程在JAVA堆中预先分配一小块内存区域，即TLAB（Thread Local Allocation Buffer）。哪个线程要分配内存，就在那个线程的TLAB空间先分配，当TLAB的内存使用完了才需要同步锁定。
  >   - 通过-XX:+/-UserTLAB,设计是否使用TLAB

- 内存分配完成后，虚拟机将分配到的内存空间都初始化为零值。如果使用了TLAB，则这一过程提前至TLAB分配时进行。这一步保证了对象不被赋值也可以使用，程序能够访问到这些字段的数据类型对应的零值（0，null，false等）

- 完成上述工作之后，从虚拟机角度看一个新的对象已经产生了，但是从java角度来看，对象才刚刚开始，方法还没有执行，所有字段都还是零值。

### 双亲委派模型

JVM通过双亲委派模型进行类的加载，当然我们也可以通过集成java.lang.ClassLoader来实现自定义的类加载器。

- 当一个类加载器收到加载任务，会先交给父类加载器去完成，因此最终任务会传递到顶层启动类加载器。
- 只有父类无法完成加载任务的时候，子类才会尝试加载。

- [ ] 为什么要使用双亲委派模型？

  因为这样可以避免重复加载，当父类已经加载过该类的时候，就没有必要子类再加载一次

- [ ] JVM在搜索类的时候，如何判断两个class是相同的呢？

  JVM在判断两个class是否相同的时候，不仅要判断两个类的类名是否相同，还要判断是否由同一个类加载器实例加载的。

- [ ] 既然JVM提供了默认的类加载器，为什么还要自定义类加载器？

  因为java中默认提供的ClassLoader，只加载指定目录下的jar 和 class，如果我们想要加载其他位置的类或者jar时

#### 破坏双亲委派模型

为什么需要破坏双亲委派模型？

因为在某些情况下父类加载器需要加载的class文件由于受到加载范围的限制，父类无法加载到指定的文件，这个时候就需要子类加载器来进行加载。

按照双亲委派模式的话，是子类委托父类去加载class文件，这个时候需要破坏双亲委派模型才能加载成功父类想要加载的类，也就是说父类会委托子类去加载它所需要的class文件。

以Driver接口为例，由于Driver接口定义在jdk中，而其由各个数据库提供商来实现，比如mysql 就提供了 MYSQL Connector，这些实现类都是放在classpath目录下的。

那么问题来了，DriverManager（也由JDK提供）要价在各个实现了Driver接口的实现类（classpath），然后进行管理，但是DriverManager由启动类加载器加载，而其实现类是由服务提供商提供的，由应用程序类加载器加载，这个时候启动类加载器就需要委托应用类加载器来加载Driver的实现，从而破坏双亲委派模型。

![image-20200515200215123](upload\image-20200515200215123.png)

## 认识运行时数据区

![image-20200513141259589](upload\image-20200513141259589.png)

![image-20200513215336719](upload\image-202005132153367？“